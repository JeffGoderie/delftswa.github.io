# Play Framework

###Abstract

<!--
###Introduction to/Goal of Play Framework
-->
## What is Play?

You want to develop your next big web application? 
Or your team asked if they please could use Scala, or Play?
This chapter explains what the Play Framework is, what it is made of, how you can use it, how you can contribute to it, and who else is involved.

The [Play Framework](https://playframework.com/) is a Web Application Framework for both Java and Scala.
Play provides you the tools to quickly and easily develop scalable, modern, and fast web applications.
Web Application frameworks come a 
[dime](https://github.com/showcases/web-application-frameworks) 
[a](http://en.wikipedia.org/wiki/Comparison_of_web_application_frameworks) 
[dozen](http://www.bestwebframeworks.com/).
On the other hand, only a few frameworks for type safe languages like Java and Scala exist.
Play allows you to implement in either or both Scala and Java, 
utilise the power of a strong compiler, 
with good support from a company and a large community.

In our opinion, and from our experience, Play should be your number one choice in a number of cases. 
First of all, if your development team is used to Java or Scala, you can step right in. 
Play offers your team the confidence that type safe languages bring.
It allows large teams to work together creating large, multi-modular apps, 
while ensuring compatibility of concurrent changes through type checking.
If your team wants to learn Scala, Play is the way to go: since it supports Java too, you can easily convert later on, and begin your Scala journey with small steps.
When handling large amounts of streaming data Play has [got you covered](https://www.playframework.com/documentation/latest/Iteratees). When serving a Real-Time app (for example a chat app) Play [integrates](https://www.playframework.com/documentation/latest/ScalaAkka) nicely with Akka's Actor system.

In the following chapter we will give some background to Play: it's features and architecture, how you can contribute to Play yourself, and who are the stakeholders that influence it's development.

## How to Play?
The [documentation](https://playframework.com/documentation/latest) provides a good starting point to create your application.
But besides how to use Play, of which features does it exist? And how are these features realised?

### Features
Web Application Frameworks generally provide a HTTP server, request parsing utilities, a way to deliver responses, and often caches, database access layers, templating libraries, and 
localisation. Play is no different.

The features of Play are divided over several modules. All HTTP features are located in the play-server and netty modules for example. View templating is even externalised to outside the project, in the form of [Twirl](https://github.com/playframework/twirl). The features that are not modularised live in the play-core module. This includes routing, mvc logic, form validation, localisation, and several utilities.

![](module-diagram/modules-main.png)

The above diagram shows most of the modules, and their dependencies. 
The test modules and Java-specific modules are excluded to provide a clearer view, but can be found in the [full diagram](module-diagram/modules-full.png). 
Much of the functionality is contained in the main Play module, central in the diagram. 
This main module depends only on these high level modules, required for basic operation:

- [Play Iteratees](https://www.playframework.com/documentation/latest/Iteratees), contains monadic structures for generating and consuming lazy streams
- [Play JSON](https://www.playframework.com/documentation/latest/ScalaJson), contains JSON parsing and modification functionality
- Play Netty Utils, contains HTTP utilities (e.g. Cookie parsing)
- Build Link, contains Java interfaces to support building user code with different Scala versions than used for Play's build

The many other modules extend that minimal Play application. 
For example for Caching, JDBC Databases, different HTTP back-ends (Netty or Akka), request filtering (Gzip, CSRF), WebServices (contains tools for outbound connections, OAuth and OpenId).

Modularisation is important when building applications that scale.
Not only can separate teams work on their own module, bundling functionality, reducing coupling,
but separate application modules can even be deployed separately, leveraging horizontal scalability. Also, unused modules can be disabled, lowering resource usage. 
Furthermore Scala [compilation speeds are improved](https://www.playframework.com/documentation/latest/CompilationSpeed) when creating smaller modules, for several reasons, including the parallelisation and limiting the amount of compilation steps.

The developers of Play focussed a lot on modularising Play in the past and continue to do so today. To visualize this the following [interactive graph](http://delftswa2014.github.io/team-playframework/modules.html) shows the size in LOC of each module as a different slice of the total code base. The overlaying text is dynamic and shows the commits in the currently hovered changes.

[![Modules over time](modules-over-time.png)](http://delftswa2014.github.io/team-playframework/modules.html)

First of all we can see that lots of modules were added over time. Also existing modules disappeared, as was the case with Twirl and Anorm. The main trend is adding modules instead of extending existing modules, and sometimes modules are split into smaller submodules. Altoghether the developers have done a great job to keep modules small and focussed.

### Who's helping?
As any developer knows, the best tool for learing is looking up your questions on [Stackoverflow](http://www.stackoverflow.com).
For well adopted frameworks, StackOverflow provides answers for almost all questions found by programmers.

We found that there is a relative constant activity on StackOverflow regarding the Play Framework.
We compared the activity for Play to the activity for Spring MVC. 
Spring MVC is a Java Web Application Framework on top of [Spring](http://nl.wikipedia.org/wiki/Spring_Framework), which exists since 2002 already.
Spring is a huge ecosystem, already at major version 4, so it is interesting to compare to the much newer Play Framework.

The comparison is shown in the diagram below. 
The fact that Play has less questions could mean that Play is easier to use than Spring MVC, or that more people are using Spring. Both seem reasonable: Play is very well documented, and Spring MVC has wide adoption due to Spring, convincing people to use that whole platform.
Compared to their estimated sizes (see [jobs](#what-s-next-for-me) below) however, Play has relatively many questions.

![diagram](frequenogramStackoverflow.png)

Getting exact usage numbers is hard however, as Play does not advertise itself in headers.
This causes sites like [BuiltWith.com](http://trends.builtwith.com/framework/Play-Framework) not to measure its world wide usage correctly. [This BuiltWith-profile](http://builtwith.com/ddb.tudelft.nl) for example does not list the (actual) usage of Play.

### What's next for me?
In the perspective of a developer using Play, it could be interesting to see if there are any work oppertunities.
As in the previous section we compare this to the existing Spring MVC framework. 

Our metric here, the amount of job openings, relates to the question of how adopted Play is.
The more jobs we found, the more adopted Play is. 
We looked at the amount of jobs on [indeed](http://indeed.com), for which one of the frameworks is listed.
This metric is purely indicative.

![Job openings](job.png)

From this we can see that there exist frameworks that are far more adopted by employers, concluded from the amount of job openings.
We think that this is due to the fact that traditionally PHP and Javascript are the most common web languages,
and now that Javascript is a back-end language too, it is becoming really huge, 
because so many people (think to) know it already.
The demand for Play developers is relatively low, but still considerable, even having surpassed the good-old ASP.NET.
Play operates in a niche (Scala) in a niche (JVM), for which demand is lower, 
but compared to Scalatra, it is scoring good in its niche. 

## How to contribute?
While many developers would only use Play for developing their own applications, there exists also a possibility to contribute to Play.
The source code of the Play Framework is managed in the [Github](https://github.com/playframework/playframework) ecosystem. 
In this git project, [general rules](https://www.playframework.com/documentation/2.3.x/Guidelines) have to be observed, such as there can be no commits made to the 'master' branch.
Developers are discouraged to use particular code constructs, such as: Locks, casting or modifying the global state.
Since the project includes both Java and Scala languages, contributors are asked to make sure their contributions work on both platforms.
The [guidelines](https://github.com/playframework/playframework/blob/master/documentation/manual/hacking/Guidelines.md) also specify where your code needs to go and what package name it should bear.
All contributed code needs to be correctly formatted using [Scalariform](https://github.com/mdr/scalariform).
By doing this the code style remains uniform throughout the project.

### Workflow
The general workflow of commiting code is as follows:

0.  Make sure you have signed the [Typesafe CLA](www.typesafe.com/contribute/cla), if not, sign it online.
1.  An issue should be made on github, explaining what you want to fix or implement, this helps to tell others in the project what you are working on.
2.  You write code locally, while observing the [standardisation guidelines](https://www.playframework.com/documentation/2.3.x/Guidelines#Pull-Request-Requirements). You commit to a local branch with a meaningful name.
3.  As a general rule, every piece of code that is added must be accompanied by test code.
Almost every PR we analysed (that provides contributions to major parts of Play) and that is merged, contained test code.
This way, the developers of Typesafe ensure that all added code has corresponding test code.
3.  The commit message should be an one line summary of what the commit is doing. The description should contain an enumerated list of what you have done.
4.  Before you make a pull request, commits should be squashed into a single commit, while observing the previous rule for the commit message.
5.  Finally you open a pull request to merge your commit into playframework/playframework master. 

For most people contributing to Play, the contributions should come from a fork of the original project.

<!-- How and when the source is automatically build. -->
Play utilizes a [continuous integration](https://playframework2.ci.cloudbees.com/) service called [Jenkins](http://jenkins-ci.org/) hosted by [CloudBees](https://www.cloudbees.com/).
This service is configured to automatically build certain branches (such as 'master' or '2.3.x').
Also all pull requests will be automatically build, or can be rebuild by using a certain keyword in a github pull request comment ([`@play-pull-request-validator try again`](https://github.com/playframework/playframework/pull/4007#issuecomment-76663971)).

<!-- How the binaries are released for testing and use. -->
To obtain the Play framework binaries, you can use the  [Typesafe Activator](https://typesafe.com/community/core-tools/activator-and-sbt).
From the [website](https://playframework.com/download) the latest version of the  Activator can be downloaded, but it is also available via [brew install typesafe-activator](http://brew.sh/).
Activator helps build and configure play projects.
For novice users Activator provides a nice web interface by running `activator ui`, some bare Scala and Java application templates and example projects are available from there.
Activator will download Play and other dependencies for a developer using SBT, using Maven or Ivy repositories.
It is possible to use other [releases](https://playframework.com/download#older-versions) or  [snapshots](https://www.playframework.com/documentation/2.3.x/BuildingFromSource#Use-in-projects) by adjusting the SBT dependency, from a [Maven/Ivy repository](https://www.playframework.com/documentation/2.3.x/Repositories).




### Who's merging?
The main integrator is James Roper, and besides James also Rich Dougherty and Peter Vlughter acted in the role of integrator.
Of the [10 pull requests](https://github.com/delftswa2014/team-playframework/issues/8) we studied extensively, James merged 7 of the 8 pull requests that were merged.

We have been able to identify several concerns that the integrators looked into. 
First of all, the integrators focussed on improving the system, while keeping external interfaces [the same if possible](https://github.com/playframework/playframework/pull/3888#issuecomment-72795185). 
Secondly, the integrators looked to see if the contributor also added the corresponding documentation, when the code impacts external behaviour. 
When breaking changes would be merged, the integrators tried to formulate reasons why to introduce the change. 
Reasons that were considered satisfactory include constraining Play to the specs of [HTTP](https://github.com/playframework/playframework/pull/3939) or [JSON](https://github.com/playframework/playframework/pull/3888), for example.
When introducing these changes, the integrators seem to want to have at least [one transitional release](https://docs.google.com/a/typesafe.com/document/d/11sVi1-REAIDFVHvwBrfRt1uXkBzROHQYgmcZNGJtDnA/pub), in which old and new API's co-exist, with the original version of the API being deprecated. 
This allows for a smoother transition to new API's.



## Who's playing?

When you choose which framework you use you commit yourself to this framework. It is essential to know the background of the framework to make a good choice.
Having a context is essential to be able to do a good comparison.
Knowing which stakeholders are involved is important as it shows if other parties have confidence in the platform and if people are involved in the project.

### Context View

### Stakeholders
The most important stakeholder is Typesafe Inc. Typesafe Inc. is the creator of the Play Framework. 
Apart from the Play Framework, it [leads development](http://typesafe.com/products/typesafe-reactive-platform) of open source projects like Scala, Akka and sbt.

Typesafe is a stakeholder that can be identified with multiple roles: it is a *Communicator*, a *Maintainer*, and alos an *Assessor*, as Typesafe ensures that each pull request of Play is conform legal [regulation](http://www.typesafe.com/contribute/cla).

Other stakeholders can be identified. Together with their roles they are listed in the table below. For a detailed overview, we refer to [the Stakeholder Analysis](D1.md#stakeholders).

| Type | Entities |
|---|---|
| Developers | Construct and deploy the system. Most active developers are employees of Typesafe. <br>[@jroper](https://github.com/jroper), [@guillaumebort](https://github.com/guillaumebort), [@pk11](https://github.com/pk11), [@richdougherty](https://github.com/richdougherty) |
| Users | Users of the Play Framework are the type of stakeholder that make use of the system. These are companies that use Play to build their (often client-facing) web services: <br> [LinkedIn](https://www.linkedin.com), [Coursera](https://www.coursera.org), [Klout](https://klout.com/home), [The Guardian](http://www.theguardian.com/uk), [BBC](http://www.bbc.com), many others |
| Supporters | Cloud Platforms as a service (PaaS) that support the Play Framework for their users: <br> [Amazon Web Services (AWS)](http://aws.amazon.com/opsworks/), [Jelastic](http://jelastic.com), [Heroku](https://www.heroku.com), [Google App Engine (GAE)](https://cloud.google.com/appengine/docs) |
| Funders | The stakeholders that fund the development of a system. These are venture capitals that have funded Typesafe Inc.: <br> [Greylock Partners](http://www.greylock.com), [Shasta Ventures](http://www.shastaventures.com), [Juniper Networks](http://www.juniper.net/us/en/homepage-campaign.page) |

In the diagram below, the stakeholders' power with respect to their interest are shown in a [Power/Interest Grid](http://www.mindtools.com/pages/article/newPPM_07.htm). Stakeholders in the top right are the most important stakeholders of the system.

<!-- Maybe superflous as we already have the table:
<a alt="Stakeholder Diagram" href="https://cloud.githubusercontent.com/assets/791189/6330391/19e5d764-bb78-11e4-92f2-2a527f6a229c.png"><img src="https://cloud.githubusercontent.com/assets/791189/6330391/19e5d764-bb78-11e4-92f2-2a527f6a229c.png" height="250"></a>
-->

![Power/Interest Grid](https://cloud.githubusercontent.com/assets/791189/6330393/1ce56cea-bb78-11e4-863f-e839c2763f02.png)

## Conclusion
The end


<!-- The end -->
----------------------------------

###Context view & module overview
_Research from D2 that has been finished._

###Standardisation & organisation
_Research from D2 that has been finished. This includes:_

* _Design_
* _Testing_
* _Monitoring_
* _Instrumentation_
* _Code organisation_

###Perspectives
_Research from D2 that has been finished._
_This includes the Software product line perspective._
_Another perspective still has to be researched and written._

####Evolution perspective on the Context view
In D1 we've talked about the context view.
In this view we took a very neutral perspective, describing the context of Play in a diagram, and explaining the different entities (people, organisations, competitors etc.).
In this new perspective, that we have dubbed the 'evolution perspective', we will make an attempt to describe the same entities as before, but in the light of the evolution of Play: Where will it go?

#####Typesafe
Typesafe would like to see a broad adoption of all of their tools: Play, sbt, Scala, Akka.
Since all of these support each other as well are dependent on another it is key that all of these progress.
Typesafe states they are all in on Reactive development.
They support this movement by giving trainings, consulting as well as going to conferences.

#####External organisations
Typesafe relies on GitHub for coding and Googlegroups for communication.
However they are not dependent on these platforms.
In case there arises a problem in using these, Typesafe has alternatives to choose from.

#####Tools
Play is already trying to become less dependant of other tools such as Netty.
This is visible from the fact that they are trying to push Akka as their HTTP backend (which currently is in experimental status). 
This allows Play to be less dependant of other systems.

#####Competition
We've talked about a number of competitors in D4 (adoption). For an open-source platform such as Play it always is important to attract enough users and developers to keep the framework alive and advancing.
Supporting a modern language (Scala) and a modern design philosophy (Reactive) Play offers what one should expect from a web-framework. But the competition is fierce and Scala is not a very widely adopted language.
The ability of Play to support both Java and Scala should form the unique selling point that keeps this framework ahead of the competition.

#####Users
The list of well-known users of Play is not very large. The framework could definitely benefit from the exposure that can come when well-known companies embrace a technology.
As long as there are a handful of large users, Play could enjoy enough exposure to be able to sustain itself.
To keep the users with the framework as it develops, it is important for the users to be able to install newer versions of the framework without too much trouble.
We have noted that Play has extensive documentation on migrating to newer versions in the form of [Migration Guides](https://www.playframework.com/documentation/2.3.x/Migration23).
This way Play can be more easily upgraded to newer versions.
We also see that on the [roadmap](https://docs.google.com/document/d/11sVi1-REAIDFVHvwBrfRt1uXkBzROHQYgmcZNGJtDnA/pub) there are measures taken to make sure the upgrade to the next major version (3.0) can occur as smoothly as possible by providing a binary and source compatible in-between version (2.5) that will warn the developers of any deprecated API use.
Now developers have an additional step in between that their application will still work on, and allows developers to move on to the next version, without completely breaking their apps.

#####Concluding the evolution perspective
In the landscape of web-application frameworks Play doesn't form a huge mountain, but rather an odd-shaped hill that can prove to be very versatile and unique.
Its <abbr title="Unique Selling Point">USP</abbr> that it both supports Java and Scala can be a big win, 
but it can also hold the project back too much because effectively it needs to support twice as much.


