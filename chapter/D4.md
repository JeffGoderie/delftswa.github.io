#Metrics
This section describes the quality of the software, using the [GQM](http://www.im-institute.org/gqm/gqm%20guide%20non%20printable.pdf). 
The complete approach is summarised in the following diagram:

![GQM diagram](gqm.png)
<!--- 
	You can adopt the diagram on this page, please update the gqm.png snapshot.
http://www.nomnoml.com/#view/%0A[Goal]%0A[Goal]->[Scalability]%0A[Goal]->[Maintainability]%0A[Scalability]->[Resources%20per%20request]%0A[Scalability]->[Throughput]%0A[Maintainability]->[Module%20size%20LOC/module]%0A[Maintainability]->[Module%20size%20over%20time]%0A[Maintainability]->[#Spin-off%20modules]
-->

##Goal
Play is a framework that aims to be chosen by its clients in cases where large web applications have to be developed. 
Therefore, one of the major goal of the developers of Play can be defined as: _"Developing an attractive web application framework that users want to build web applications of scale with."_


Attractive is objective and may be interpreted by a broad set of characteristics such as; reliable, robust, flexible, maintainable, etc. 
The following sections will go in depth on some of these characteristics.

##Questions
In this section, three questions will be formulated that focus on characterising the assessment or achievement of the goal that has been defined in the section above.

###Maintainability
The first metric is defined by the maintainability of the system. 
We define this as _"How maintainable is the Play Framework?"_. 
Maintainability forms an important aspect, the web environment and the applications around it develop over time. 
The technology advances over the past ten years are vast and to keep up with further technological demands, the system must be able to adapt to this.


###Scalability
The second question that can be formulated is _"How scalable is the Play framework?"_.
Scalability is an important aspect for a web development framework that aims to support large web applications. 
It ensures that a web application continues to operate according to standards, while the demand increases.

##Metrics

###Scalability
There are two types of scalability that can be measured. Horizontal scalability is the amount of nodes that can be added to a system in order to improve the speed under large loads. Vertical scalability is the amount of resources (in processing power) that can be added to a node to improve the speed of the system. Play offeres built in horizontal scaling principles, for example that it is stateless my nature. However, in this question we will focus on vertical scalability, as clearer measurements exists for measuring the characteristics of this type of scalability.
 
The metrics that can be defined for measuring vertical scalability of a web application are:

* Throughput
* Latency

#####Throughput
The throughput of a system is a key aspect that tells a lot about the efficiently of the application. 
The higher the throughput, the more requests it may be able to handle per unit of time.
This increases the amount of requests that can be handled when the demand of requests is high and thus increases the scalability of the framework.

The metric we define for throughput is: _HTTP requests/second (RPS)_.

The HTTP request in Play 2.3 and earlier are by default [handled by Netty](https://www.playframework.com/documentation/1.1/api/play/mvc/class-use/Http.Request.html). 
Several tests have been performed between the most commonly used web development frameworks. 
A few of the results are listed below.

* 9.000 requests/second in a test performed by [TechEmpower](http://www.techempower.com/blog/2013/04/05/frameworks-round-2/). The test consisted of JSON-request using an Amazon EC2 Large instance. Netty itself takes the lead with a staggering 37.9k request/sec.
* 2.400 requests/second in a test performed by [Christian Papauschek](http://blog.papauschek.com/2013/04/real-world-performance-of-the-play-framework-on-ec2/) in 2013. In this test, a Play 2.1.1-scala production instance running on EC2 large was used to service complete webpages.


#####Time per request
Latency is a relevant metric for web applications, because it provides information about the efficiency of handling a request. 
The more efficient a request is handled, the lower the latency in large demands and thus the more scalable the application is.

The metric (applied to Play) we define for this is: _ms/HTTP request_.

The Play framework maintains a testing tool ([Prune](https://github.com/playframework/prune)) that automates the performance tests of different versions of Play framework. 
One of the metrics that is tested is latency. 

Prune automates 6 tests cases that differ in the kind of operation. 
Test cases vary from a simple plain text response of `Hello world` to a download response of 50kbit. 
 
In the test results below it is shown that the latency of the 50k requests is significantly higher (~40ms) than the latency of the plain text response (~0.5ms). 

![](./50k_chuck.png)
_50kbit request_

![](./simple_request.png)
_Simple plain text request_


A typical difference between Scala and Java applications of Play users exists. 
Writing in Scala generally allows for more readable and understandable asynchronous code, versus the traditional synchronous Java style. 
James Roper [describes](http://architects.dzone.com/articles/scaling-scala-vs-java) this as "Scala helps you scale much more than Java does". 
In a typical example case the Java variant would be written in a blocking fashion, degrading the performance of concurrent requests, lowering vertical scalability. 
This effect may contribute to the difference in the latency measurements between a Java and a Scala application.

Judging from these graphs, we can see that the Play Framework performs constantly well on the metrics.
With the exception of a few versions.
We think it is important to keep a close watch on these metrics, as they tell about the performance of the system. 







###Maintainability

#####Module size LOC

#####Module size over time

#####Number of spin-off modules

